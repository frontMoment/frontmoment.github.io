[{"title":"regexp","date":"2017-08-28T02:03:09.000Z","path":"2017/08/28/regexp/","text":"元字符123456789101112131415&quot;^&quot; ：^会匹配行或者字符串的起始位置，有时还会匹配整个文档的起始位置。 &quot;$&quot; ：$会匹配行或字符串的结尾&quot;\\b&quot; :不会消耗任何字符只匹配一个位置，常用于匹配单词边界 如 我想从字符串中&quot;This is Regex&quot;匹配单独的单词 &quot;is&quot; 正则就要写成 &quot;\\bis\\b&quot; \\b 不会匹配is 两边的字符，但它会识别is 两边是否为单词的边界 &quot;\\d&quot;: 匹配数字,例如要匹配一个固定格式的电话号码以0开头前4位后7位，如0737-5686123 正则:^0\\d\\d\\d-\\d\\d\\d\\d\\d\\d\\d$ 这里只是为了介绍&quot;\\d&quot;字符，实际上有更好的写法会在 下面介绍。&quot;\\w&quot;：匹配字母，数字，下划线.例如我要匹配&quot;a2345BCD__TTz&quot; 正则：&quot;\\w+&quot; 这里的&quot;+&quot;字符为一个量词指重复的次数，稍后会详细介绍。&quot;\\s&quot;：匹配空格 ,例如字符 &quot;a b c&quot; 正则：&quot;\\w\\s\\w\\s\\w&quot; 一个字符后跟一个空格，如有字符间有多个空格直接把&quot;\\s&quot; 写成 &quot;\\s+&quot; 让空格重复&quot;.&quot;：匹配除了换行符以外的任何字符&quot;[abc]&quot;: 字符组 匹配包含括号内元素的字符 反义词1234567891011写法很简单改成大写就行了，意思与原来的相反，这里就不举例子了 &quot;\\W&quot; 匹配任意不是字母，数字，下划线 的字符 &quot;\\S&quot; 匹配任意不是空白符的字符 &quot;\\D&quot; 匹配任意非数字的字符 &quot;\\B&quot; 匹配不是单词开头或结束的位置 &quot;[^abc]&quot; 匹配除了abc以外的任意字符 量词 先解释关于量词所涉及到的重要的三个概念 贪婪(贪心) 如&quot;*&quot;字符 贪婪量词会首先匹配整个字符串，尝试匹配时，它会选定尽可能多的内容，如果 失败则回退一个字符，然后再次尝试回退的过程就叫做回溯，它会每次回退一个字符，直到找到匹配的内容或者没有字符可以回退。相比下面两种贪婪量词对资源的消耗是最大的， 懒惰(勉强) 如 “?” 懒惰量词使用另一种方式匹配，它从目标的起始位置开始尝试匹配，每次检查一个字符，并寻找它要匹配的内容，如此循环直到字符结尾处。 占有 如”+” 占有量词会覆盖事个目标字符串，然后尝试寻找匹配内容 ，但它只尝试一次，不会回溯，就好比先抓一把石头，然后从石头中挑出黄金 &quot;*&quot;(贪婪) 重复零次或更多 例如”aaaaaaaa” 匹配字符串中所有的a 正则： “a*” 会出到所有的字符”a” &quot;+&quot;(懒惰) 重复一次或更多次 例如”aaaaaaaa” 匹配字符串中所有的a 正则： “a+” 会取到字符中所有的a字符， “a+”与”a“不同在于”+”至少是一次而”“ 可以是0次， 稍后会与”?”字符结合来体现这种区别 &quot;?&quot;(占有) 重复零次或一次 例如”aaaaaaaa” 匹配字符串中的a 正则 ： “a?” 只会匹配一次，也就是结果只是单个字符a “{n}” 重复n次 例如从”aaaaaaaa” 匹配字符串的a 并重复3次 正则： “a{3}” 结果就是取到3个a字符 “aaa”; “{n,m}” 重复n到m次 例如正则 “a{3,4}” 将a重复匹配3次或者4次 所以供匹配的字符可以是三个”aaa”也可以是四个”aaaa” 正则都可以匹配到 &quot;{n,}&quot; 重复n次或更多次 与{n,m}不同之处就在于匹配的次数将没有上限，但至少要重复n次 如 正则”a{3,}” a至少要重复3次 把量词了解了之后之前匹配电话号码的正则现在就可以改得简单点了^0\\d\\d\\d-\\d\\d\\d\\d\\d\\d\\d可以改为”0\\d+−\\d7可以改为”0\\d+−\\d7”。 这样写还不够完美如果因为前面的区号没有做限定，以至于可以输入很多们，而通常只能是3位或者4位， 现在再改一下 “^0\\d{2,3}-\\d{7}”如此一来区号部分就可以匹配3位或者4位的了 懒惰限定符12345678910111213141516171819&quot;*?&quot; 重复任意次，但尽可能少重复 如 &quot;acbacb&quot; 正则 &quot;a.*?b&quot; 只会取到第一个&quot;acb&quot; 原本可以全部取到但加了限定符后，只会匹配尽可能少的字符 ，而&quot;acbacb&quot;最少字符的结果就是&quot;acb&quot; &quot;+?&quot; 重复1次或更多次，但尽可能少重复 与上面一样，只是至少要重复1次 &quot;??&quot; 重复0次或1次，但尽可能少重复 如 &quot;aaacb&quot; 正则 &quot;a.??b&quot; 只会取到最后的三个字符&quot;acb&quot; &quot;&#123;n,m&#125;?&quot; 重复n到m次，但尽可能少重复 如 &quot;aaaaaaaa&quot; 正则 &quot;a&#123;0,m&#125;&quot; 因为最少是0次所以取到结果为空 &quot;&#123;n,&#125;?&quot; 重复n次以上，但尽可能少重复 如 &quot;aaaaaaa&quot; 正则 &quot;a&#123;1,&#125;&quot; 最少是1次所以取到结果为 &quot;a&quot; 捕获分组12345&quot;(exp)&quot; 匹配exp,并捕获文本到自动命名的组里&quot;(?&lt;name&gt;exp)&quot; 匹配exp,并捕获文本到名称为name的组里&quot;(?:exp)&quot; 匹配exp,不捕获匹配的文本，也不给此分组分配组号 零宽断言123456789101112131415&quot;(?=exp)&quot; 匹配exp前面的位置 如 &quot;How are you doing&quot; 正则&quot;(?&lt;txt&gt;.+(?=ing))&quot; 这里取ing前所有的字符，并定义了一个捕获分组名字为 &quot;txt&quot; 而&quot;txt&quot;这个组里的值为&quot;How are you do&quot;;&quot;(?&lt;=exp)&quot; 匹配exp后面的位置 如 &quot;How are you doing&quot; 正则&quot;(?&lt;txt&gt;(?&lt;=How).+)&quot; 这里取&quot;How&quot;之后所有的字符，并定义了一个捕获分组名字为 &quot;txt&quot; 而&quot;txt&quot;这个组里的值为&quot; are you doing&quot;;&quot;(?!exp)&quot; 匹配后面跟的不是exp的位置 如 &quot;123abc&quot; 正则 &quot;\\d&#123;3&#125;(?!\\d)&quot;匹配3位数字后非数字的结果&quot;(?&lt;!exp)&quot; 匹配前面不是exp的位置 如 &quot;abc123 &quot; 正则 &quot;(?&lt;![0-9])123&quot; 匹配&quot;123&quot;前面是非数字的结果也可写成&quot;(?!&lt;\\d)123&quot;","tags":[{"name":"正则表达式 RegExp","slug":"正则表达式-RegExp","permalink":"http://imoment.vip/tags/正则表达式-RegExp/"}]},{"title":"webpack-module","date":"2017-07-16T12:54:37.000Z","path":"2017/07/16/webpack-module/","text":"webpack模块打包导出变量详解，涉及js分配内存机制webpack打包文件时候，我们通常使用module.exports = {} 或者 exports.getName = function(){}，这样的方式来导出模块的代码，大家有没有真正了解为什么我们要这样写？其中的原理是什么？今天来详解一下。先看几个例子Demo 1 1234567891011121314151617181920212223var module = &#123; exports:&#123;&#125;&#125;function doSomeThing(module,exports) &#123; module.exports = &#123; id:1001, name:&apos;Moment&apos; &#125;&#125;doSomeThing(module,module.exports)console.log(module)// 输出结果// 形参传入引用类型，函数内部直接给__module.exports__赋予了新内存地址，// 所以此时千万不要对__exports__导出变量，无效// module = &#123;// exports: &#123;// id:1001,// name:&apos;Moment&apos;// &#125;// &#125; Demo 2 12345678910111213141516171819202122232425var module = &#123; exports:&#123;&#125;&#125;function doSomeThing(module,exports) &#123; module.exports = &#123; id:1001, name:&apos;Moment&apos; &#125; exports.addr = &apos;Hangzhou&apos;; exports.getAddr = function()&#123;&#125;;&#125;doSomeThing(module,module.exports)console.log(module)// 输出结果// __module.exports__被赋予新的引用类型，地址指向已经改变，// 形参__exports__的赋值还是在之前的内存地址修改，对此时的module.exports无效// module = &#123;// exports: &#123;// id:1001,// name:&apos;Moment&apos;// &#125;// &#125; Demo 3 123456789101112131415161718192021222324var module = &#123; exports:&#123;&#125;&#125;function doSomeThing(module,exports) &#123; module.exports.id = 1001; module.exports.name = &apos;Moment&apos;; exports.addr = &apos;Hangzhou&apos;; exports.getAddr = function()&#123;&#125;;&#125;doSomeThing(module,module.exports)console.log(module)// 输出结果// __module.exports__ 和 __exports__内存地址指向同一处，所以修改同步生效// module = &#123;// exports: &#123;// id:1001,// name:&apos;Moment&apos;,// addr = &apos;Hangzhou&apos;;// getAddr = function()&#123;&#125;;// &#125;// &#125; Demo 4 12345678910111213141516171819202122var module = &#123; exports:&#123;&#125;&#125;function doSomeThing(module,exports) &#123; exports = &#123; id:1001, name:&apos;Moment&apos; &#125; exports.addr = &apos;Hangzhou&apos;; exports.getAddr = function()&#123;&#125;;&#125;doSomeThing(module,module.exports)console.log(module)// 输出结果// 输出空对象，保持初始化的状态，exports被赋予新的内存地址，不会对原有地址改变// module = &#123;// exports: &#123;// &#125;// &#125; 综上所述，我们在使用 module.exports 或者 exports 来导出变量的注意点，千万不要去改变exports的内存地址(也就是重新赋值)123456exports.id = &apos;11111&apos; // rightexports.id = &#123;&#125; // rightexports = &#123;&#125; // errormodule.exports.id = &apos;1111&apos; // rightmodule.exports.id = &#123;&#125; // rightmodule.exports = &#123;&#125; // right,但是此时不能再使用exports导出,除非重新给exports赋值(exports = module.export;)，保持两者关联 其实只要你对js的引用类型足够了解的话，以上都不是问题，写一个最小例子1234var a = &#123;id:1&#125;;var b = a;b.id = 2;此时a.id === 2,因为a 和b 共同指向了同一个内存地址 1234var a = &#123;id:1&#125;;var b = a;b = &#123;name:&apos;b&apos;&#125;此时a 还是为&#123;id:1&#125;，因为当b被重新赋值时，不是去修改原地址，而是给b重新分配新的内存地址，所以a的地址保存不变 最后附上webpack打包的bundle文件，关键点做了注释说明，为什么我们使用的是module.exports 和 exports来导出模块？123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596(function(modules) &#123; // webpackBootstrap // The module cache var installedModules = &#123;&#125;; // The require function function __webpack_require__(moduleId) &#123; /*--------------------------------------------------------------------------*/ // webpack 缓存处理，对已经加载过的js模块直接从缓存拿，避免重复调用，性能优化 /*--------------------------------------------------------------------------*/ // Check if module is in cache if(installedModules[moduleId]) &#123; return installedModules[moduleId].exports; &#125; // Create a new module (and put it into the cache) var module = installedModules[moduleId] = &#123; i: moduleId, l: false, exports: &#123;&#125; &#125;; /*--------------------------------------------------------------------------*/ // 这里就是调用每个模块文件的地方，传入module.exports、module、require三个参数 // 使得我们可以通过module.exports、module来导出模块，使用require来引入模块 /*--------------------------------------------------------------------------*/ // Execute the module function modules[moduleId].call(module.exports, module, module.exports, __webpack_require__); // Flag the module as loaded module.l = true; /*--------------------------------------------------------------------------*/ // 这里是导出每个模块文件的地方 // 通过module.exports来导出需要暴露给其他模块require的函数、变量 /*--------------------------------------------------------------------------*/ // Return the exports of the module return module.exports; &#125; // expose the modules object (__webpack_modules__) __webpack_require__.m = modules; // expose the module cache __webpack_require__.c = installedModules; // define getter function for harmony exports __webpack_require__.d = function(exports, name, getter) &#123; if(!__webpack_require__.o(exports, name)) &#123; Object.defineProperty(exports, name, &#123; configurable: false, enumerable: true, get: getter &#125;); &#125; &#125;; // getDefaultExport function for compatibility with non-harmony modules __webpack_require__.n = function(module) &#123; var getter = module &amp;&amp; module.__esModule ? function getDefault() &#123; return module[&apos;default&apos;]; &#125; : function getModuleExports() &#123; return module; &#125;; __webpack_require__.d(getter, &apos;a&apos;, getter); return getter; &#125;; // Object.prototype.hasOwnProperty.call __webpack_require__.o = function(object, property) &#123; return Object.prototype.hasOwnProperty.call(object, property); &#125;; // __webpack_public_path__ __webpack_require__.p = &quot;&quot;; // Load entry module and return exports return __webpack_require__(__webpack_require__.s = 0);&#125;)([ /*--------------------------------------------------------------------------*/ 这里是每个文件的模块代码，0,1,2三个文件id,自执行函数的数组形参传递，进行初始化 /*--------------------------------------------------------------------------*/ /* 0 */ /*--------------------------------------------------------------------------*/ 这里的形参名叫module, exports, __webpack_require__， 所以明白我们已经明白为什么要使用module.exports和exports了 require关键字会在打包过程中被__webpack_require__替代掉 /*--------------------------------------------------------------------------*/ (function(module, exports, __webpack_require__) &#123; eval(&quot;var a = __webpack_require__(1)\\nvar b = __webpack_require__(2)\\nconsole.log(a+b);\\n\\n\\n//////////////////\\n// WEBPACK FOOTER\\n// ./index.js\\n// module id = 0\\n// module chunks = 0\\n\\n//# sourceURL=webpack:///./index.js?&quot;); &#125;), /* 1 */ (function(module, exports) &#123; eval(&quot;var a = 1;\\nmodule.exports = a;\\n\\n\\n//////////////////\\n// WEBPACK FOOTER\\n// ./modules/a.js\\n// module id = 1\\n// module chunks = 0\\n\\n//# sourceURL=webpack:///./modules/a.js?&quot;); &#125;), /* 2 */ (function(module, exports) &#123; eval(&quot;var b = 10;\\nmodule.exports = b;\\n\\n\\n//////////////////\\n// WEBPACK FOOTER\\n// ./modules/b.js\\n// module id = 2\\n// module chunks = 0\\n\\n//# sourceURL=webpack:///./modules/b.js?&quot;); &#125;)]);","tags":[{"name":"webpack module module.exports 内存分配","slug":"webpack-module-module-exports-内存分配","permalink":"http://imoment.vip/tags/webpack-module-module-exports-内存分配/"}]},{"title":"mysql-pm2","date":"2017-05-12T11:20:40.000Z","path":"2017/05/12/mysql-pm2/","text":"关于新服务器的系统迁移最近购买了腾讯云服务器，正在把之前的搬瓦工上面的系统逐渐迁移到新服务器上，其中涉及到基于thinkjs的数据迁移 1.第一步，首先将老服务器上面的mysql数据库导出，保证数据的同步1mysqldump -u root -p root --databases moment.db &gt;/root/project/data.sql 2.在新系统安装mysql,使用yum安装1yum -y install mysql-server mysql 3.登录mysql,导入刚刚导出的数据文件data.sql12mysql -u root -psource /root/project/data.sql 4.以上步骤已经完成了数据库的数据同步，最后基于pm2发布服务这里我遇到了一个小坑，因为换了个服务器，然后我的项目文件目录路径和之前有了改变，而我项目的pm2.json文件的cwd指向了之前的老目录，导致 pm2 start pm2.json时访问页面一直502，之后使用pm2 show命令查看了error log,发现一直报错”ENOENT: no such file or directory, uv_chdir”. 其实就是pm2的启动服务的js文件找不到，发现问题之后，使用pm2 stop,然后pm2 start pm2.json还是不行，后来使用pm2 kill杀掉进程，在执行pm2 start pm2.json大功告成。","tags":[{"name":"mysql pm2 thinkjs pm2 kill","slug":"mysql-pm2-thinkjs-pm2-kill","permalink":"http://imoment.vip/tags/mysql-pm2-thinkjs-pm2-kill/"}]},{"title":"git-diff","date":"2017-05-09T07:35:02.000Z","path":"2017/05/09/git-diff/","text":"git 有四种状态，三个区域状态：untracked,unmodified,modified,staged区域：工作区域，暂存区域，本地仓库[edit files actions] // 工作区域文件修改了 git diff //是查看 工作区域 与 暂存区域 的文件差别 git add . // 文件修改从 工作区域=&gt;暂存区域 git diff –cached //是查看 暂存区域 与 本地仓库 的文件差别 git commit -m ‘’ // 文件修改从 索引区=&gt;本地仓库 git diff HEAD //是查看 本地仓库 与 远程仓库 的文件差别","tags":[{"name":"git diff","slug":"git-diff","permalink":"http://imoment.vip/tags/git-diff/"}]},{"title":"mac OSX系统下使用charles 抓 mobile 的包","date":"2017-04-20T10:57:11.000Z","path":"2017/04/20/charles-mobile/","text":"mac OSX系统下使用charles 抓 mobile 的包1.首先手机和Mac必须在同一局域网下,比如都连接了A wifi, 2.手机设置网络代理,iphone下 打开设置手动代理路径打开 : 设置-&gt;Wi-Fi-&gt;A wifi ,找到HTTP代理,手动代理填写服务器和端口号,比如: 12192.168.8.1328888 3、此时理论上可以抓包了 4、对于抓取HTTPS请求,需要在手机上安装charles证书打开charles,按照以下步骤:Help-&gt;SSL Proxying-&gt;Install Charles Root Certificate on a Mobile Device or Remote Brower然后手机浏览器打开https://charlesproxy.com/getssl 地址下载ssl证书 5.在charles的设置SSL Proxy SettingsProxy-&gt;SSL Proxy Settings添加你想要抓包的https域名,端口设置为443即可 完成以上步骤就可以使用charles抓mobile的包了","tags":[{"name":"charles mobile proxy mac","slug":"charles-mobile-proxy-mac","permalink":"http://imoment.vip/tags/charles-mobile-proxy-mac/"}]},{"title":"mac OSX系统下使用charles 抓PC 浏览器的包","date":"2017-04-20T10:40:34.000Z","path":"2017/04/20/charles-pc/","text":"mac OSX系统下使用charles 抓PC 浏览器的包charles 安装配置不在本次教程之中1、勾选顶部状态栏的 Proxy-&gt;Start Recording 和 maxOS Proxy 2、打开mac代理配置界面,具体步骤如下: (1)steps:系统偏好设置-&gt;网络-&gt;Wi-Fi 高级-&gt;代理 (2)勾选网页代理(HTTP) 和 安全网页代理(HTTPS)代理服务器地址和端口号设置为(charles 默认端口8888) 12127.0.0.18888 然后点击好,应用就能抓取PC 浏览器的请求了。 *chrome默认不是使用系统代理,如果发现抓不到chrome的包,请检查一下chrome://settings/ 里面的代理设置","tags":[{"name":"charles pc browser proxy mac","slug":"charles-pc-browser-proxy-mac","permalink":"http://imoment.vip/tags/charles-pc-browser-proxy-mac/"}]},{"title":"webstorm-vue","date":"2016-11-11T10:33:49.000Z","path":"2016/11/11/webstorm-vue/","text":"Webstorm Vue es6报错解决方案Webstorm项目设置为Ecmascript6 Webstorm安装Vuejs插件 然后修改.vue文件中的script标签修改为如下格式 1&lt;script type=&quot;text/babel&quot;&gt; 如果你使用less的话,.vue文件中的style标签修改为如下格式1&lt;style rel=&quot;stylesheet/less&quot; lang=&quot;less&quot; scoped&gt; 通过如上两个修改,可以友好的使用vue开发了","tags":[{"name":"webstorm vue es6","slug":"webstorm-vue-es6","permalink":"http://imoment.vip/tags/webstorm-vue-es6/"}]},{"title":"vue-plugin","date":"2016-10-20T10:39:51.000Z","path":"2016/10/20/vue-plugin/","text":"Vue.js插件书写规范Vue插件书写规范，导出一个带有install方法的对象使用时，可以通过官方写法将自定义插件挂载到Vue上面：123import Vue from &apos;vue&apos;import YourPlugin from &apos;YourPlugin&apos;Vue.use(YourPlugin) 闭包里导出一个带有install方法的对象123456789101112131415161718(function () &#123; var YourPlugin = &#123; install:function(Vue,options)&#123; // todo your code,such as // Vue.component(&apos;CustomComponent&apos;, CustomComponent) &#125; &#125; // 这里为了支持CMD,AMD,CommonJs,以及script标签导入的方式 if (typeof exports == &quot;object&quot;) &#123; module.exports = YourPlugin &#125; else if (typeof define == &quot;function&quot; &amp;&amp; define.amd) &#123; define([], function()&#123; return YourPlugin &#125;) &#125; else if (window.Vue) &#123; Vue.use(YourPlugin) &#125;&#125;)() 至于为什么要这样写,为什么要导出install方法？相信大家肯定有疑问，这里摘录Vue源码的use方法,大家就能一目了然12345678910111213141516Vue.use = function (plugin) &#123; /* istanbul ignore if */ if (plugin.installed) &#123; return &#125; // additional parameters var args = toArray(arguments, 1) args.unshift(this) if (typeof plugin.install === &apos;function&apos;) &#123; plugin.install.apply(plugin, args) &#125; else &#123; plugin.apply(null, args) &#125; plugin.installed = true return this &#125; 当前后续最好将插件通过npm publish发布到npm包里面，这样其他小伙伴就能通过以下方式直接安装了1npm install YourPlugin","tags":[]},{"title":"cheat","date":"2016-09-25T10:48:36.000Z","path":"2016/09/25/cheat/","text":"更好用的shell查询命令工具,cheat安装cheat(需要python环境) 1pip install cheat 使用方式：1cheat ls 其他帮助命令：1man ls 为什么要使用cheat?相信每个人都用过 man 来查看某个命令的使用方法,这个确实很全面,但是说明文字很长,而且看着很累,解释不言简意赅,对于英语能力一般的人确实是个体力活cheat使用更简短的语言描述,和实例来展示该命令的使用方式比如:1cheat ls 下面是ls命令的常用方式说明1234567891011121314# Displays everything in the target directoryls path/to/the/target/directory# Displays everything including hidden filesls -a# Displays all files, along with the size (with unit suffixes) and timestampls -lh# Display files, sorted by sizels -S# Display directories onlyls -d */","tags":[]},{"title":"git-tips","date":"2016-08-16T11:00:00.000Z","path":"2016/08/16/git-tips/","text":"git一些常用的操作记录一、git checkout恢复某个已修改的文件（撤销未提交的修改）：1git checkout file-name 例如：git checkout src/abc.js 比如修改的都是js文件，不必一个个撤销，可以使用1git checkout *.js 撤销所有修改1git checkout . 二、删除 git add 文件1234567git add abc.jsgit rm --cached abc.jsgit add .git rm --cached . 三、解决本地多个ssh-key问题为github配置新的key ，取名为github12345~/.ssh$ ssh-keygen -t rsa -C &quot;xxx@gmail.com&quot; -f ~/.ssh/github~/.ssh$ lsgithub github.pub id_rsa id_rsa.pub known_hosts 其中默认的是id_rsa四、Existing folder or Git repository123456cd existing_foldergit initgit remote add origin git@xxxxxx:xxx/xxxx.gitgit add .git commitgit push -u origin master 最后推荐大家使用一个更好的提交工具gitmoji 和git cz安装方法参考这个地址git cz 和 gitmoji规范了提交文件的流程,填写更友好的commit信息,方便做code review","tags":[]},{"title":"new-blog","date":"2016-04-05T10:19:44.000Z","path":"2016/04/05/new-blog/","text":"Good news,新的Blog诞生,以后坚持写博客,分享技术,学习技术,better and better","tags":[{"name":"new blog","slug":"new-blog","permalink":"http://imoment.vip/tags/new-blog/"}]}]